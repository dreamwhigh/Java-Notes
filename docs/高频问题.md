持续更新中

## Java 部分

正则表达式



equals（） 和 hashCode（） 为什么要同时重写



### List

List接口的常用实现类有ArrayList和LinkedList。使用时，通常声明为List类型，实例化为ArrayList或LinkedList，例如：

```java
List<String> l = new ArrayList<String>();// 利用ArrayList类实例化List集合
List<String> l2 = new LinkedList<String>();// 利用LinkedList类实例化List集合
```

### HashMap

#### 存储结构

内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对，它包含了四个字段。

```java
transient Entry[] table;

static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;
    }
```

#### 解决冲突

##### 拉链法

采用**头插法**，将key相同的键值对插到当前所在桶链表的头部。

查找过程：

- 计算键值对所在的桶；O（1）
- 在链表上顺序查找，时间复杂度显然和链表的长度成正比。O（N），N为链表长度

##### 开放定址法

<https://blog.csdn.net/feinik/article/details/54974293>

#### put 操作

HashMap 允许插入键为 null 的键值对。但是因为**无法调用 null 的 hashCode() 方法**，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap **使用第 0 个桶存放键为 null 的键值对**。

#### 计算桶下标

```
int hash = hash(key);//计算hash值
int i = indexFor(hash, table.length);//取模求桶下标
```

##### 计算hash值

采用移位运算和异或运算来计算hash值

```java
h ^= (h >>> 20) ^ (h >>> 12);
return h ^ (h >>> 7) ^ (h >>> 4);
```

##### 取模

取模运算转化为位运算，前提是 x = 2^n^ ，x 的二进制中只有一个 1 的形式。

**y % x 等价于 y & (x - 1)**

```java
y       : 10110010
x-1     : 00001111
y&(x-1) : 00000010
等价于
y   : 10110010
x   : 00010000
y%x : 00000010
```

计算完 hash值后，再对桶个数 capacity 取模（hash%capacity），这时保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。

```java
static int indexFor(int hash, int capacity) {
    return hash & (capacity-1);
}
```

#### 扩容

##### 基本原理

设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此**平均查找次数的复杂度为 O(N/M)**。

为了降低查找成本，应尽可能减小 N/M ，保证M 

尽可能大，HashMap 采用**动态扩容**来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。

相关参数有：

| 参数       | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。 |
| size       | 键值对数量。                                                 |
| threshold  | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。 |
| loadFactor | 装载因子，table 能够使用的比例，threshold = (int)(newCapacity * loadFactor)。 |

table 的初始容量为 16， 每次扩容， capacity 变为原来的两倍，保证其始终为 2 的 n 次方。

扩容使用 resize() 实现，需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。

```java
if (size++ >= threshold)
        resize(2 * table.length);
```

##### ？ resize() 具体的实现方法

#### 扩容-重新计算桶下标

采用一个特殊机制来重新计算桶下标。

假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：

```
capacity     : 00010000
new capacity : 00100000
```

对于一个 Key，

- 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；
- 如果为 1，那么得到的结果为原来的结果 +16。

#### 计算数组容量

HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。

##### 计算掩码

对于 10010000，它的掩码为 11111111

```
mask |= mask >> 1    11011000
mask |= mask >> 2    11111110
mask |= mask >> 4    11111111
```

mask+1 是大于原始数字的最小的 2 的 n 次方

```
num     10010000
mask+1 100000000
```

#### 链表转红黑树

从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。

与 HashTable 的比较

- Hashtable 使用 synchronized 来进行同步。

- HashMap 可以插入键为 null 的 Entry。

- HashMap 的迭代器是 fail-fast 迭代器。

- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。

- **线程安全性**

  Hashtable 使用 synchronized 来进行同步，在修改数据时锁住整个 HashTable；HashMap不是线程安全的，但是效率高；多线程操作时，可以采用线程安全的ConcurrentHashMap，它使用了分段锁，并不对整个数据进行锁定，效率比Hashtable要高好多倍。

- **初始容量和扩容方式**

  HashTable 初始容量为 11，扩容为 newCapacity = 2 * oldCapacity + 1;

  HashMap 初始容量为 16，扩容为 newCapacity = 2 * oldCapacity，始终保证容量为 2 的 n 次方。

- **Null**

  key和value都是对象，并且不能包含重复key，（key 重复时，会直接更新对应的 value 值，而不会同时加入两个相同的 key）但可以包含重复的value。

  Hashtable中，key和value都不允许出现null值；

  HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。

- **Hash 值不同**

  |              | Hashtable                | HashMap                        |
  | ------------ | ------------------------ | ------------------------------ |
  | 计算 Hash 值 | 直接用key的hashCode()    | 移位和异或运算重新计算 Hash 值 |
  | 确定桶下标   | 取模运算 hash % capacity | 与运算 hash & (capacity-1)     |

  ```java
  //Hashtable
  index = (hash & 0x7FFFFFFF) % tab.length//括号内是为了将负的hash值转化为正值
  
  //HashMap
  index = hash & (tab.length – 1)
  ```

- 遍历方式

  Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

  HashMap的Iterator是fail-fast迭代器。当有其它线程改变了HashMap的结构（增加，删除，修改元素），将会抛出ConcurrentModificationException。

  JDK8之前的版本中，Hashtable是没有fast-fail机制的。在JDK8及以后的版本中 ，HashTable也是使用fast-fail的

- contains() 和 elments() 方法

  Hashtable比HashMap多提供了elments() 和contains() 两个方法。

  elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。

  contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。

- 父类不同

  Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口

### ConcurrentHashMap

ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。

Segment 继承自 ReentrantLock。默认的并发级别为 16，也就是说默认创建 16 个 Segment。



#### 待写问题

List、Set、Map常用的有哪些，linkedList、ArrayList的区别，HashSet底层实现原理，HashMap底层数据结构

​    HashMap 底层数据结构是什么？    

​    红黑树是什么样的数据结构？    

​    HashMap 什么时候会扩容？怎么扩的？为什么新的大小需要保持在 2^n？与操作与 2 ^ n 有什么关系？

### GC

#### 垃圾收集算法

1. 标记-清除

   标记阶段，在活动对象头部打上标记；

   清除阶段，进行对象回收并取消标志位，将连续的空闲分块合并。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

1. 标记-整理

   让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

3. 复制

   将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

不足

- 只使用了内存的一半。

4. 分代收集

- 新生代使用：复制算法

- 老年代使用：标记 - 整理 算法

#### 问题

新生代分几部分，用什么GC算法，为什么？

新生代分为三块区域，一块较大的 Eden 空间和两块较小的 Survivor 空间，采用整理算法，因为新生代gc比较频繁、对象存活率低，用复制算法在回收时的效率会更高，也不会产生内存碎片。

为什么老年代不用复制算法？

复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以在栈的老年代不适用复制算法。

老年代一般用哪种垃圾收集算法？

老年代采用 **标记 - 整理** 算法。

CMS 使用哪种算法？怎么解决内存碎片的问题？

采用 **标记-清除** 算法，标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不**提前触发一次 Full GC**。

什么情况下会发生栈内存溢出？

- 栈溢出：当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；

  栈溢出是指不断的调用方法，不断的压栈，最终超出了栈允许的栈深度，就会发生栈溢出，比如递归操作没有终止，死循环。

- 栈内存溢出：栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

  对于一台服务器而言，每一个用户请求，都会产生一个线程来处理这个请求，每一个线程对应着一个栈，栈会分配内存，此时如果请求过多，这时候内存不够了，就会发生栈内存溢出。



方法区什么时候会发生溢出？

加载很多的类时

大小为一个G的新生代和两个G的新生代，其他条件相同，二者的垃圾回收时间是两倍关系吗？

怎么查看进程一共发生了几次 FullGC   ?



### JUC

#### ThreadLocal的作用



线程之间的操作会互相影响吗？为什么？



线程池的七大参数



如何同时运行多个线程？

CyclicBarrier：

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

计数器初始值为线程总数，线程执行 **await() 方法**之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续同时执行。

 CountdownLatch：

用来控制一个或者多个线程等待多个线程。

维护了一个计数器 cnt，每次调用 **countDown() 方法**会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

CyclicBarrier 和 CountdownLatch 的区别：CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

线程在countDown()之后，会继续执行自己的任务，而CyclicBarrier会在所有线程任务结束之后，才会进行后续任务。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png)

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png)



线程包含哪几个状态？

新建状态（New)，就绪状态（Runnable），运行状态（Running），阻塞状态（Blocked），死亡状态（Dead）。



1. 线程池的构造函数有哪几个参数？
2. 什么情况下会达到最大线程数？
3. 线程池中的线程是前台还是后台？

1. 知道优雅关闭吗？



HTTP 状态码



## 计算机网络

### TCP

#### 三次握手

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 处于 SYN-SENT 状态，向 B 发送连接请求报文，SYN=1，ACK=0，初始的序号seq=x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号ack = x+1，初始的序号 seq=y，这时A为established 状态，B 为SYN-RCVD状态。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1，确认号为 y+1，序号为 x+1，此时A，B 均为established 状态。
- B 收到 A 的确认后，连接建立。



**SYN 泛洪攻击**



#### 四次挥手

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

- 初始A，B 均为established 状态。
- A 发送连接释放报文，FIN=1，seq=u，A 为 FIN_WAIT_1 状态。
- B 收到之后发出确认，ACK=1，seq=v，确认号为u+1，此时A为FIN_WAIT_2，B为CLOSE_WAIT， TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1，ACK=1，seq=w，确认号为u+1，此时A为TIME_WAIT，B为LAST_ACK 状态。
- A 收到后发出确认报文，ACK=1，seq=u+1，确认号为w+1，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。B 收到 A 的确认后释放连接。此时A、B都关闭了，状态变为CLOSED。 

**CLOSE-WAIT**

让服务器B端发送还未传送完毕的数据，传送完毕之后，B会发送 FIN 连接释放报文。

**TIME_WAIT持续2MSL**

一个TCP 报文 （Segment） 在网络中的最长生存时间为MSL（Maximum Segment Life）

- 确保B能够接收到A回复的最后一个ACK包，如果ACK包未收到，B会重传最后一个FIN包。ACK和FIN在网络中的最长生存时间就为2MSL，这样就可以可靠的断开TCP的双向连接。 
- 让本连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接中不会出现旧的连接请求报文。

**为什么握手是三次，但挥手需要四次**

在建立连接时，服务器可以把**SYN和ACK放在一个包中发送**。

在断开连接时，大多数情况**FIN和ACK需要在两个数据包中**：B端收到FIN包后，需要先向A回复ACK包，断开A到B端的连接。等到B将数据传送完毕后，在对A端发送FIN包，断开B到A端的连接。

#### 超时重传和快速重传

- 超时重传：当超时时间到达时，发送方还未收到对端的ACK确认，就重传该数据包
- 快速重传（快重传与快恢复）：当后面的序号先到达，如接收方接收到了1、 3、 4，而2没有收到，就会立即向发送方重复发送三次ACK=2的确认请求重传。如果发送方连续收到3个相同序号的ACK，就重传该数据包。而不用等待超时

### TCP 与 UDP

- TCP**面向连接**（三次握手的连接过程）；UDP是**无连接**的
- TCP提供**可靠交付**（确认，握手，重传机制），无差错，不重复，不丢失，按序到达；UDP**尽最大可能交付**
- TCP **面向字节流**，把字节流组织成大小不等的数据块；UDP**面向报文**，对应用层传下来的报文不合并也不拆分，只是添加UDP首部
- 每一条 TCP连接只能是**点对点**的；UDP支持**一对一，一对多，多对多**的交互通信（适合消息的广播，多播发布）
- TCP首部字段有**20个字节**开销；UDP首部只有**8个字节**
- TCP**时延大**，适用于**大文件**；UDP**时延小**，适用于**小文件**

#### 基于TCP或UDP的应用层协议

- TCP： FTP、HTTP、Telnet、SMTP、POP3、HTTPS
- UDP：DNS、SNMP、NFS

| 应用程序   | FTP   | TFTP | TELNET | SMTP | DNS     | HTTP | SSH  | MYSQL | DHCP  | SNMP    |
| ---------- | ----- | ---- | ------ | ---- | ------- | ---- | ---- | ----- | ----- | ------- |
| 熟知端口   | 21/20 | 69   | 23     | 25   | 53      | 80   | 22   | 3306  | 67/68 | 161/162 |
| 传输层协议 | TCP   | UDP  | TCP    | TCP  | UDP/TCP | TCP  | TCP  | TCP   | UDP   | UDP     |



## 数据库部分

### 数据库系统原理

[数据库系统原理](<https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86>)

#### 事务的四大特性 ACID

- **原子性（Atomicity）**

  一个事务内所有操作共同组成一个原子包，是不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

- **一致性（Consistency）**

  数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

  事务提交前后，永远只可能存在事务提交前的状态和事务提交后的状态，从一个一致性的状态到另一个一致性状态，而不可能出现中间的过程态。即事物的执行结果是量子化状态，而不是线性状态。

- **隔离性（Isolation）**

  一个事务所做的修改在最终提交以前，对其它事务是不可见的。

- **持久性（Durability）**

  一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

**关系**

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

#### 并发一致性问题

- **丢失修改**

  T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

- **脏读**

  T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

  一个事务 T2 处理过程里读取了另一个未提交的事务 T1 中的数据。

- **不可重复读**

  T2 读取一个数据，T1 对该数据做了修改（**UPDATE操作**）。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

- **幻读**

  T1 读取某个范围的数据，T2 在这个范围内插入新的数据（**INSERT操作**），T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同

  幻读和不可重复读都是读取了另一条**已经提交的事务**（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）

产生并发不一致性问题主要原因是**破坏了事务的隔离性**，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

#### 事务隔离级别

- **未提交读（Read Uncommitted）**

  事务中的修改，即使没有提交，对其它事务也是可见的。

- **提交读（Read Committed）**

  一个事务只能读取已经提交的事务所做的修改，即一个事务所做的修改在提交之前对其它事务是不可见的。

  解决**脏读**问题

- **可重复读（Repeatable Read）**

  在开始读取数据（事务开启）时，不再允许**修改**操作。保证在同一个事务中多次读取同样数据的结果是一样的。

  解决**脏读、不可重复读**问题，但不能解决幻读问题。因为**不可重复读**对应的是修改，即**UPDATE操作**。但**幻读**问题对应的是插入**INSERT操作**。

- **可串行化（Serializable）**

  最高的事务隔离级别，该级别下，强制事务**串行化顺序执行**。

  解决**脏读、不可重复读与幻读**问题，但是该事务隔离级别效率低下，比较耗数据库性能，一般不使用。

不同隔离级别下会出现的问题：

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| -------- | ---- | ---------- | ------ |
| 未提交读 | √    | √          | √      |
| 提交读   | ×    | √          | √      |
| 可重复读 | ×    | ×          | √      |
| 可串行化 | ×    | ×          |        |

#### MVCC

**多版本并发控制**（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎**实现隔离级别的一种具体方式**，用于实现**提交读和可重复读**这两种隔离级别。



#### Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

在可重复读（REPEATABLE READ）隔离级别（InnoDB 默认的隔离级别）下，使用 MVCC + Next-Key Locks 可以**解决幻读问题**。

```sql
select..from for update
//在扫描到的任何索引记录上加排它的next-key lock，还有主键聚集索引加排它锁 
```

##### Record Locks

锁定一个记录上的索引。

##### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。

Next-Key Locks 是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙，是一个前开后闭区间。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +supremum)
```

### MySQL

数据库B+树的结构特点



为什么叶子节点不存数据



mysql的binlog和redolog的作用



聚簇索引和非聚簇索引



一条update语句，一定会更新索引吗？



索引的数据结构、B+树结构、为什么下面要有链表相连各记录



组合索引的命中问题（最左匹配原则）



1. 为什么索引需要最左前缀匹配？
2. B 树和 B+ 树有什么区别？
3. 为什么需要在叶子节点里包含父节点？

如何分析 SQL 语句是否用到索引？

数据库引擎都有哪些？分别有什么特点？

innodb索引了解吗？底层原理是什么？

数据库调优的方式？怎么查看一条语句用了什么索引？

索引什么情况下失效



### Linux

怎么利用 Linux 命令查看进程端口号？

### 非技术问题

最近看过什么专业书？



平时出了问题怎么解决，上什么网站。

CSDN，博客园，GitHub，QQ技术群，



逛哪些技术公众号。



反问面试官

对我本次面试的评价

需要在我的技术栈中增加什么